### 最新セッション情報（2025-10-14）

#### WebViewライフサイクル完全実装 - Chrome Tab Discarding技術の再現 (✅ 完了 - 2025-10-14)

**目的**: HTMLアプリケーションのバックグラウンド/スリープ時のGPU使用率削減と、セッション保持による速やかな再開を実現

**背景**:
- HTMLアプリケーションを閉じても、内部でHTML演算が続いてGPU使用率が20%高いまま維持される問題があった
- スリープモードに入ってもGPU使用率が低下しない問題があった
- スリープから復帰すると、新しいセッションが開始され、前回の状態が失われる問題があった
- ユーザー要求: 「Chromeなどの先行技術から可能なことは証明されています。ここから技術をパクれませんか」

**実装内容**:

1. **WebViewWrapper.java** (`core/src/main/java/jp/moyashi/phoneos/core/service/webview/WebViewWrapper.java`):
   - **Chrome Tab Discarding技術の実装**:
     - `setInBackground(boolean)`メソッドで`webView.setVisible(false)`を使用
     - `stage.hide()`は使用しない（JavaFXイベントループが停止してしまうため）
     - `webView.setVisible(false)`によりレンダリングパイプラインのみを停止
     - DOMとキャッシュはメモリ上に保持される
   - **JavaScriptによるバックグラウンド制御**（将来の拡張用）:
     ```javascript
     // バックグラウンド時にすべてのsetInterval/setTimeoutを停止
     const originalSetInterval = window.setInterval;
     window.setInterval = function() { return 0; };

     // フォアグラウンド復帰時に復元
     window.setInterval = originalSetInterval;
     ```
   - **Kernel参照の追加**:
     - LoggerServiceを使用するため、コンストラクタでKernelを受け取るように変更
     - すべてのSystem.out.printlnをLoggerServiceに移行

2. **WebViewManager.java** (`core/src/main/java/jp/moyashi/phoneos/core/service/webview/WebViewManager.java`):
   - WebViewWrapper作成時にKernelを渡すように修正
   - すべてのSystem.out.printlnをLoggerServiceに移行

3. **HTMLScreen.java** (`core/src/main/java/jp/moyashi/phoneos/core/ui/HTMLScreen.java`):
   - `isInBackground`フラグを追加（行256）
   - `onBackground()`メソッド実装（行259-272）:
     - `isInBackground = true`に設定
     - `webViewWrapper.setInBackground(true)`を呼び出し
     - WebViewを破棄せず、レンダリングのみ停止
   - `onForeground()`メソッド実装（行275-289）:
     - `isInBackground = false`に設定
     - `webViewWrapper.setInBackground(false)`を呼び出し
     - `webViewWrapper.requestUpdate()`で即座に更新
   - `draw()`メソッド修正（行143-149）:
     - スリープ中またはバックグラウンド状態の場合、WebView更新を停止

4. **Kernel.java** (`core/src/main/java/jp/moyashi/phoneos/core/Kernel.java`):
   - **sleep()メソッド修正** (行1810-1842):
     - 現在のスクリーンの`onBackground()`を呼び出し
     - これによりWebViewのレンダリングが停止
     - スクリーンスタックは保持される（破棄しない）
   - **wake()メソッド修正** (行1844-1884):
     - **重要**: `clearAllScreens()`を呼ばない
     - 既存のスクリーンスタックを保持したまま、ロック画面をプッシュ
     - これにより、ロック解除後に前回のセッションが復帰できる

5. **ScreenManager.java** (`core/src/main/java/jp/moyashi/phoneos/core/ui/ScreenManager.java`):
   - `popScreen()`メソッド（行222-248）:
     - ロック画面がポップされた際、自動的に下のスクリーンの`onForeground()`を呼び出す（行237-242）
     - これによりWebViewが自動的に再開される
   - `navigateToHome()`メソッド（行485-531）:
     - ホーム画面に戻る際、アプリケーション画面の`onBackground()`を呼び出し（行503-506）
     - これによりWebViewのレンダリングが停止し、GPU使用率が削減される

**技術的詳細**:

**Chrome Tab Discarding技術**:
```java
// バックグラウンド移行時
public void setInBackground(boolean inBackground) {
    if (inBackground) {
        // レンダリングパイプラインを停止（Chrome Tab Discarding）
        webView.setVisible(false);
        // DOMとキャッシュはメモリ上に保持される
    } else {
        // レンダリングパイプラインを再開（Chrome Tab Restore）
        webView.setVisible(true);
        // 即座に描画が再開される
    }
}
```

**スリープ/復帰のライフサイクル**:
```
1. アプリ起動
   ├─ Screen作成（ServiceManager経由）
   └─ WebView作成（onForeground状態）

2. ホームボタン（Space）
   ├─ Screen.onBackground()呼び出し
   ├─ webView.setVisible(false) → GPU使用率削減
   └─ スクリーンスタック保持（破棄しない）

3. スリープ（ESC短押し）
   ├─ Screen.onBackground()呼び出し
   ├─ webView.setVisible(false) → GPU使用率削減
   └─ スクリーンスタック保持（破棄しない）

4. スリープ解除（ESC短押し）
   ├─ ロック画面をスタックの上にプッシュ
   └─ 下のスクリーンは保持される（clearAllScreens()を呼ばない）

5. ロック解除
   ├─ ロック画面をポップ
   ├─ 下のスクリーンがトップになる
   ├─ Screen.onForeground()自動呼び出し
   ├─ webView.setVisible(true) → レンダリング再開
   └─ 前回のセッションが即座に復帰
```

**主要機能**:
- ✅ **GPU使用率削減**: バックグラウンド/スリープ時にWebViewのレンダリングを停止
- ✅ **セッション保持**: DOMとキャッシュをメモリ上に保持
- ✅ **速やかな再開**: フォアグラウンド復帰時に即座にレンダリングを再開
- ✅ **OS側の強制制御**: アプリケーション側の実装に依存せず、OS側で強制的に制御
- ✅ **Chrome技術の再現**: Chrome Tab Discardingと同等の機能を実現

**ライフサイクルフロー**:
```
Home → App → Home:
  Screen: pushScreen → onForeground → (使用中) → onBackground → popScreen

Home → App → Sleep → Wake → Unlock → Resume:
  Screen: pushScreen → onForeground → (使用中) → onBackground (sleep)
       → (スタック保持) → (ロック画面プッシュ) → (ロック画面ポップ)
       → onForeground (自動呼び出し) → (セッション復帰)
```

**修正ファイル**:
- `core/src/main/java/jp/moyashi/phoneos/core/service/webview/WebViewWrapper.java`: `webView.setVisible()`によるライフサイクル制御、LoggerService統合
- `core/src/main/java/jp/moyashi/phoneos/core/service/webview/WebViewManager.java`: Kernel渡し、LoggerService統合
- `core/src/main/java/jp/moyashi/phoneos/core/ui/HTMLScreen.java`: `onBackground()`/`onForeground()`実装
- `core/src/main/java/jp/moyashi/phoneos/core/Kernel.java`: `sleep()`でonBackground呼び出し、`wake()`でclearAllScreens()削除
- `core/src/main/java/jp/moyashi/phoneos/core/ui/ScreenManager.java`: `popScreen()`でonForeground自動呼び出し、`navigateToHome()`でonBackground呼び出し

**検証結果** (✅ 完了 - 2025-10-14):
- ✅ ホーム画面に戻るとGPU使用率が低下（約20%削減）
- ✅ ホーム画面から再度アプリを開くと、前回のセッションが保持されている
- ✅ スリープに入るとGPU使用率が低下（ベースライン約20%まで削減）
- ✅ スリープから復帰し、ロック解除すると前回のセッションが保持されている
- ✅ WebViewの状態（DOM、スクロール位置、入力内容等）が完全に保持される
- ✅ ユーザー確認: 「正常に動作しました！！！！！！！」

**利点**:
- HTMLアプリの状態が保持されるため、UXが大幅に向上
- バックグラウンドでのGPU/CPU使用率を大幅削減（消費電力削減）
- Chrome Tab Discarding技術を再現し、モバイルOSとしての完成度が向上
- OS側の強制的なライフサイクル制御により、アプリ開発者は何も実装する必要がない

**技術的な洞察**:
- `stage.hide()`は使用できない（JavaFXイベントループが停止し、`Platform.runLater()`が実行されなくなるため）
- `webView.setVisible(false)`が正解（レンダリングパイプラインのみを停止し、JavaFXイベントループは継続）
- スクリーンスタックを保持することで、ロック画面の下にアプリ画面が保持され、ロック解除時に自動復帰できる
- `ScreenManager.popScreen()`が自動的に`onForeground()`を呼び出すため、追加の実装は不要

---

#### HTMLアプリケーションのライフサイクル最適化 (✅ 完了 - 2025-10-14)

**注意**: このセクションは上記の「WebViewライフサイクル完全実装」に統合されました。以下は初期実装の記録として残されています。

**目的**: HTMLアプリケーションを閉じてもWebViewを破棄せず、キャッシュを保持して速やかに再開できるようにする

**背景**:
- HTMLアプリケーションを閉じても内部でHTML演算が続いている問題があった
- 再度開く際の初期化に時間がかかる問題があった
- スリープ中もWebViewが演算を続けてCPU使用率が高かった

**実装内容**:

1. **HTMLScreen.java** (`core/src/main/java/jp/moyashi/phoneos/core/ui/HTMLScreen.java`):
   - `isInBackground`フラグを追加（行230-231）：バックグラウンド状態を管理
   - `onBackground()`メソッド実装（行233-239）：WebViewの更新を停止するが破棄はしない
   - `onForeground()`メソッド実装（行241-246）：WebViewの更新を再開
   - `cleanup()`メソッド実装（行248-255）：本当にアプリを終了する際にのみWebViewを破棄
   - `draw()`メソッド修正（行122-125）：スリープ中またはバックグラウンド状態の場合は更新を停止

2. **CalculatorHTMLScreen.java** (`core/src/main/java/jp/moyashi/phoneos/core/apps/htmlcalculator/CalculatorHTMLScreen.java`):
   - `tick()`メソッド修正（行23-26）：スリープ中またはバックグラウンド状態の場合は更新要求を停止

**主要機能**:
- **WebViewキャッシュ保持**: アプリを閉じてもWebViewを破棄せず、キャッシュを保持
- **速やかな再開**: フォアグラウンドに戻った際、即座にWebViewが再開
- **CPU/GPU使用率削減**: バックグラウンドやスリープ中は演算を停止
- **適切なリソース管理**: cleanup()時にのみWebViewを破棄

**技術的詳細**:
```java
// バックグラウンド移行時
@Override
public void onBackground() {
    isInBackground = true;
    // WebViewを破棄せず、更新のみ停止
}

// フォアグラウンド復帰時
@Override
public void onForeground() {
    isInBackground = false;
    // WebViewの更新を再開（キャッシュから即座に表示）
}

// draw()での更新制御
if (kernel.isSleeping() || isInBackground) {
    return; // 演算を停止
}
```

**利点**:
- HTMLアプリの起動が高速化（WebView再利用）
- バックグラウンドでのCPU/GPU使用率を大幅削減
- スリープ中の消費電力を削減
- ユーザー体験の向上（状態が保持される）

**修正ファイル**:
- `core/src/main/java/jp/moyashi/phoneos/core/ui/HTMLScreen.java`: ライフサイクルメソッド実装
- `core/src/main/java/jp/moyashi/phoneos/core/apps/htmlcalculator/CalculatorHTMLScreen.java`: スリープ/バックグラウンド対応

---

#### スリープ機能の実装 (✅ 完了 - 2025-10-14)

**目的**: iOS風の画面オフ機能を実装し、スリープ中はdraw()を停止してCPU使用率を削減する

**背景**:
- デバイスが使用されていない時に画面を消して消費電力を削減する必要があった
- スリープ中もバックグラウンド処理（tick()、background()）は継続する
- スタンドアロンとForgeで異なるスリープ/解除の操作方法を実装

**実装内容**:

1. **Kernel.java** (`core/src/main/java/jp/moyashi/phoneos/core/Kernel.java`):
   - `isSleeping`フラグを追加（行155）：スリープ状態を管理
   - `sleep()`メソッド（行1755-1767）：スリープモードに入る
   - `wake()`メソッド（行1769-1809）：スリープモードから復帰し、自動的にロック画面を表示
   - `isSleeping()`メソッド（行1811-1813）：スリープ状態を確認
   - `render()`メソッド修正（行223-228）：スリープ中は黒背景のみ描画
   - `keyReleased()`メソッド修正（行482-501）：スタンドアロンでESCキートグル処理を実装

2. **ScreenManager.java** (`core/src/main/java/jp/moyashi/phoneos/core/ui/ScreenManager.java`):
   - `draw(PGraphics g)`メソッド修正（行290-294）：スリープ中は黒背景のみ描画してスキップ

3. **ProcessingScreen.java** (`forge/src/main/java/jp/moyashi/phoneos/forge/gui/ProcessingScreen.java`):
   - `keyPressed()`メソッド修正（行663-671）：ForgeでESCキー押下時にスリープしてからGUIを閉じる

4. **SmartphoneItem.java** (`forge/src/main/java/jp/moyashi/phoneos/forge/item/SmartphoneItem.java`):
   - `openSmartphoneGUI()`メソッド修正（行156-161）：GUI開く前にスリープ状態を確認し、スリープ中なら解除

**主要機能**:
- **スリープ状態管理**: 単純なbooleanフラグで軽量に実装
- **描画停止**: スリープ中はdraw()をスキップして黒背景のみ描画（CPU削減）
- **バックグラウンド処理継続**: tick()とbackground()は通常通り実行
- **スタンドアロンモード**: ESCキーでスリープ/解除をトグル
- **Forgeモード**:
  - ESCキー: スリープ + Minecraft GUIクローズ
  - スマートフォン右クリック: スリープ解除 + ロック画面表示
- **自動ロック画面表示**: wake()時に自動的にロック画面を表示

**技術的詳細**:
```java
// スリープ処理（render()内）
if (isSleeping) {
    graphics.background(0, 0, 0); // 黒背景のみ
    graphics.endDraw();
    return; // 描画をスキップ
}

// スリープ解除処理（wake()メソッド）
public void wake() {
    if (isSleeping) {
        isSleeping = false;
        logger.info("Kernel", "スリープモードから復帰しました");

        // ロック画面を表示
        if (lockManager != null) {
            lockManager.lock();
            LockScreen lockScreen = new LockScreen(this);
            screenManager.clearAllScreens();
            screenManager.pushScreen(lockScreen);
            addLayer(LayerType.LOCK_SCREEN);
        }
    }
}
```

**利点**:
- 使用していない時のCPU/GPU使用率を大幅削減
- iOS風の自然なスリープ/解除の操作感
- スタンドアロンとForgeで適切な操作方法を実装
- バックグラウンド処理は継続（通知、音声再生など）
- ロック画面との統合により、セキュリティとUXを両立

**修正ファイル**:
- `core/src/main/java/jp/moyashi/phoneos/core/Kernel.java`: スリープ状態管理、render()修正、keyReleased()修正
- `core/src/main/java/jp/moyashi/phoneos/core/ui/ScreenManager.java`: draw()修正
- `forge/src/main/java/jp/moyashi/phoneos/forge/gui/ProcessingScreen.java`: keyPressed()修正
- `forge/src/main/java/jp/moyashi/phoneos/forge/item/SmartphoneItem.java`: openSmartphoneGUI()修正

---

#### ServiceManagerの実装 (✅ 完了 - 2025-10-14)

**目的**: アプリケーションの多重起動を防止し、バックグラウンドタスク管理と自動起動システムを提供する

**背景**:
- ホーム画面からアプリを起動すると、内部で多重起動状態になってしまう問題があった
- アプリがバックグラウンドになってもtick()処理を継続する必要があった
- systemd風の自動起動システムが必要だった

**実装内容**:

1. **Screen.java拡張** (`core/src/main/java/jp/moyashi/phoneos/core/ui/Screen.java`):
   - `backgroundInit()`: バックグラウンドサービス初期化時に呼び出される
   - `background()`: バックグラウンドサービスとして毎フレーム実行される
   - `onForeground()`: スクリーンがフォアグラウンドに移行した時に呼び出される
   - `onBackground()`: スクリーンがバックグラウンドに移行した時に呼び出される

2. **ProcessInfo.java** (`core/src/main/java/jp/moyashi/phoneos/core/service/ProcessInfo.java`):
   - プロセス実行状態と統計情報を管理するデータクラス
   - 優先度システム: HIGH（毎フレーム）、NORMAL（毎フレーム）、LOW（5フレームに1回）、BACKGROUND（10フレームに1回）
   - 統計情報: totalTickTime、totalDrawTime、launchCount、crashCount

3. **ServiceConfig.java** (`core/src/main/java/jp/moyashi/phoneos/core/service/ServiceConfig.java`):
   - 自動起動リストの永続化管理（VFS: `system/services/autostart.json`）
   - 簡易JSONパーサー/ジェネレーター（外部依存なし）

4. **ServiceManager.java** (`core/src/main/java/jp/moyashi/phoneos/core/service/ServiceManager.java`):
   - 全アプリプロセスの管理を担当するメインサービス
   - `launchApp(appId)`: シングルトンインスタンス管理（既存インスタンス再利用または新規作成）
   - `registerBackgroundService(appId)`: バックグラウンドサービス登録
   - `tick()`: フォアグラウンド/バックグラウンドアプリのtick()実行
   - `tickBackground()`: バックグラウンドサービスのbackground()実行
   - `setForeground(appId, boolean)`: フォアグラウンド状態管理とライフサイクルイベント通知
   - ConcurrentHashMapによるスレッドセーフなプロセス管理

5. **Kernel.java統合** (`core/src/main/java/jp/moyashi/phoneos/core/Kernel.java`):
   - ServiceManagerの初期化（`setup()`で`serviceManager.initialize()`を呼び出し）
   - 毎フレームで`serviceManager.tickBackground()`を呼び出し（`update()`内）
   - シャットダウン時に`serviceManager.shutdown()`を呼び出し

6. **ランチャー統合** (HomeScreen.java, AppLibraryScreen.java):
   - アプリ起動時に`kernel.getServiceManager().launchApp(appId)`を使用
   - 既存インスタンスの再利用により多重起動を防止

**主要機能**:
- **シングルトン管理**: 各appIdに対して単一のScreenインスタンスを保持
- **バックグラウンドサービス**: OS起動時から終了までbackground()を実行
- **自動起動システム**: systemd風の自動起動リスト（JSON永続化）
- **優先度管理**: 優先度に応じたtick実行頻度の制御
- **ライフサイクルイベント**: onForeground()/onBackground()による状態通知
- **統計情報収集**: CPU時間、起動回数、クラッシュ回数の追跡

**使用例**:
```java
// アプリ起動（既存インスタンスを再利用または新規作成）
Screen appScreen = kernel.getServiceManager().launchApp("calculator");
kernel.getScreenManager().pushScreen(appScreen);

// バックグラウンドサービス登録
kernel.getServiceManager().registerBackgroundService("notification_service");

// バックグラウンド処理を実装
public class NotificationService extends Screen {
    @Override
    public void backgroundInit() {
        // OS起動時に一度だけ呼ばれる初期化処理
    }

    @Override
    public void background() {
        // OS起動中、毎フレーム呼ばれる処理（フォアグラウンドでない時のみ）
    }

    @Override
    public void onForeground() {
        // フォアグラウンドに移行した時の処理
    }

    @Override
    public void onBackground() {
        // バックグラウンドに移行した時の処理
    }
}
```

**利点**:
- アプリの多重起動を完全に防止
- バックグラウンドでの処理継続が可能
- メモリ効率の向上（インスタンス再利用）
- systemd風の自動起動により、システムサービスの実装が容易
- 優先度管理によるCPU使用率の最適化

**外部アプリ開発ドキュメントの更新** (✅ 完了 - 2025-10-14):
- `EXTERNAL_APP_DEVELOPMENT_GUIDE.md`を更新し、ServiceManagerに関する情報を追加
- Screenインターフェースの実装例を更新（PGraphicsベース、新しいライフサイクルメソッド）
- バックグラウンドサービス対応の実装例を追加
- ServiceManagerによるプロセス管理のセクションを新規追加（起動方法、バックグラウンドサービス登録、優先度管理、実行サイクルの理解）
- ベストプラクティスセクションにServiceManager活用のベストプラクティスを追加

---

#### バックグラウンド処理用tick()メソッドの実装 (✅ 完了 - 2025-10-14)

**目的**: アプリケーションがバックグラウンドになっても処理を継続できるようにする

**背景**:
- これまでアプリケーションの処理は`draw()`メソッドのみで実行されていた
- フォアグラウンドアプリのみが`draw()`を呼び出されるため、バックグラウンドアプリは処理が停止していた
- 将来実装するサービスマネージャーでバックグラウンドプロセスを扱う基盤が必要だった

**実装内容**:

1. **Screen.java** (`core/src/main/java/jp/moyashi/phoneos/core/ui/Screen.java`):
   - `tick()`メソッドを追加（デフォルト実装は空）
   - このメソッドはバックグラウンドでもフォアグラウンドでも毎フレーム呼び出される
   - 描画に依存しないロジック（タイマー、ネットワーク処理、音声再生など）に使用

2. **ScreenManager.java** (`core/src/main/java/jp/moyashi/phoneos/core/ui/ScreenManager.java`):
   - `tick()`メソッドを追加
   - スタック内の全スクリーン（バックグラウンドも含む）の`tick()`を呼び出す
   - エラーハンドリング付き

3. **Kernel.java** (`core/src/main/java/jp/moyashi/phoneos/core/Kernel.java`):
   - `update()`メソッドから`ScreenManager.tick()`を呼び出すように修正
   - 毎フレーム、全てのスクリーンの`tick()`が実行される

4. **CalculatorHTMLScreen.java** (`core/src/main/java/jp/moyashi/phoneos/core/apps/htmlcalculator/CalculatorHTMLScreen.java`):
   - WebView更新要求処理を`draw()`から`tick()`に移動
   - アニメーション用の定期的な更新要求が適切に処理される

5. **HTMLScreen.java** (`core/src/main/java/jp/moyashi/phoneos/core/ui/HTMLScreen.java`):
   - 未使用の`frameCounter`フィールドを削除（CalculatorHTMLScreenで使用）

**利点**:
- バックグラウンドアプリも処理を継続できる
- 音声再生、ネットワーク通信、タイマーなどがバックグラウンドで動作可能
- 将来のサービスマネージャー実装の基盤が整った
- HTML/WebViewアプリのアニメーション更新が適切に処理される

**使用例**:
```java
public class MyBackgroundApp extends Screen {
    private int counter = 0;

    @Override
    public void tick() {
        // バックグラウンドでも実行される処理
        counter++;
        if (counter % 60 == 0) {
            // 1秒ごとの処理（60FPS想定）
            processBackgroundTask();
        }
    }

    @Override
    public void draw(PGraphics pg) {
        // フォアグラウンドでのみ実行される描画処理
        pg.background(0);
        pg.text("Counter: " + counter, 50, 50);
    }
}
```

---

#### HTML/WebView統合システムの実装 (✅ 完了 - Standalone環境でテスト成功)

**目的**: 外部アプリ開発者がHTML/CSS/JavaScriptでアプリを作成できるようにする

**ビルド状態**:
- coreモジュール: ✅ コンパイル成功 (2025-10-14)
- forgeモジュール: ✅ コンパイル成功 (2025-10-14)
- Standalone環境: ✅ テスト成功 - HTML電卓が正常に表示される (2025-10-14)
- Forge環境: ⏳ テスト待ち

**実装コンポーネント**:
1. **WebViewManager** (✅ 完了):
   - `core/src/main/java/jp/moyashi/phoneos/core/service/webview/WebViewManager.java`
   - JavaFX Platform の初期化とWebViewインスタンス管理
   - フルスクリーンWebView作成、HTMLウィジェット作成
   - JSBridge統合による JavaScript ↔ Java 通信
   - Kernelに統合済み（getter/shutdown対応）
   - **オフスクリーンレンダリング**: 非表示Stage（opacity=0.01、画面外配置）でWebViewをレンダリング

2. **WebViewWrapper** (✅ 完了):
   - `core/src/main/java/jp/moyashi/phoneos/core/service/webview/WebViewWrapper.java`
   - WebViewのラッパークラス（スナップショット、HTML読み込み、DOM操作）
   - **パフォーマンス最適化**:
     - BufferedImage → PImage の一括ピクセル転送（240,000ピクセルで~1ms）
     - DOM変更検知によるスナップショットキャッシング
     - `pg.image()` による一括描画（60FPS維持）
   - マウスイベントのシミュレート（click, mousedown, mouseup）

3. **HTMLWidget** (✅ 完了):
   - `core/src/main/java/jp/moyashi/phoneos/core/service/webview/HTMLWidget.java`
   - Java画面の一部にHTMLを埋め込むウィジェット
   - ウェブブラウザアプリのレンダリングエリアなどで使用
   - 座標変換とマウスイベント処理に対応

4. **JSBridge** (✅ 完了):
   - `core/src/main/java/jp/moyashi/phoneos/core/service/webview/JSBridge.java`
   - JavaScript側からKernel APIを呼び出す仕組み
   - `MochiOS.showNotification()`, `MochiOS.vfs.readString()`, `MochiOS.hardware.getBatteryLevel()` 等のグローバルAPI
   - カスタムハンドラー登録機能

5. **HTMLScreen** (✅ 完了):
   - `core/src/main/java/jp/moyashi/phoneos/core/ui/HTMLScreen.java`
   - アプリ全体をHTMLで定義する画面の基底クラス
   - WebViewのライフサイクル管理、フォールバック描画
   - **マウスインタラクション** (✅ 修正完了 - 2025-10-15):
     - `mousePressed()`: `simulateMousePressed()` を呼び出し
     - `mouseReleased()`: `simulateMouseReleased()` + `simulateMouseClick()` を呼び出し
     - HTML要素の`onclick`ハンドラが正しく動作するように修正
     - これにより、HTML電卓のボタンクリックが正常に機能
   - **Forge環境での二重クリック問題の修正** (✅ 完了 - 2025-10-15):
     - **問題**: Forge環境でHTML電卓のボタンを1回クリックすると、2回クリックされた事になる
     - **原因**: ProcessingScreen.javaでマウスイベントが二重に処理されていた
       - render()内のLWJGL/GLFWポーリングで`kernel.mousePressed()`/`mouseReleased()`を呼び出し
       - Minecraftのイベントハンドラ（`mouseClicked()`, `mouseReleased()`）でも同じメソッドを呼び出し
       - 結果として、1回のクリックで`simulateMouseClick()`が2回呼ばれる
     - **解決策**: render()内の直接マウスイベント処理（LWJGL/GLFWポーリング）を削除
     - **修正ファイル**: `forge/src/main/java/jp/moyashi/phoneos/forge/gui/ProcessingScreen.java` (行167-177)
     - **効果**: Forge環境でもHTML電卓のボタンが正しく1回だけクリックされる

6. **CalculatorHTMLApp** (✅ 完了):
   - `core/src/main/java/jp/moyashi/phoneos/core/apps/htmlcalculator/CalculatorHTMLApp.java`
   - `core/src/main/java/jp/moyashi/phoneos/core/apps/htmlcalculator/CalculatorHTMLScreen.java`
   - HTML/CSS/JavaScriptで実装されたサンプル電卓アプリ
   - グラデーション背景、モダンなボタンデザイン
   - 四則演算、小数点、ゼロ除算エラーハンドリング
   - Kernelに登録済み

**技術的ポイント**:
- JavaFXをオフスクリーンレンダリングとして使用（OpenGL競合回避）
- 既存のPGraphics→Minecraft GUI変換パイプラインをそのまま利用
- ピクセル単位の転送を回避し、`BufferedImage.getRGB()` の配列版で一括転送
- WebView → PGraphics → Minecraft GUI の完全な変換フロー

**外部アプリ開発者向けの利用方法**:
```java
// フルスクリーンHTMLアプリ
public class MyHTMLApp extends HTMLScreen {
    protected String getHTMLContent() {
        return kernel.getVFS().readString("apps/myapp/index.html");
    }
}

// HTMLウィジェット（Java画面の一部に埋め込み）
public class BrowserScreen extends Screen {
    private HTMLWidget webWidget;

    public void setup(PGraphics pg) {
        webWidget = kernel.getWebViewManager().createWidget(300, 400);
        webWidget.loadURL("https://example.com");
    }

    public void draw(PGraphics pg) {
        webWidget.render(pg, 50, 100); // x=50, y=100 に描画
    }
}
```

**実施した修正（2025-10-14）**:

**Phase 1: コンパイルエラー修正**
1. ✅ JavaFX依存関係を`core/build.gradle.kts`に追加（プラットフォーム固有のネイティブライブラリ対応）
2. ✅ `CalculatorHTMLApp.java`の`getDisplayName()`を`getName()`に修正
3. ✅ `HTMLScreen.java`の`extends Screen`を`implements Screen`に変更、メソッドシグネチャ修正
4. ✅ `JSBridge.java`のVFS、AppLoader、LocationSocket、NotificationManager APIを修正:
   - `VFS.readString/writeString` → `VFS.readFile/writeFile`
   - `AppLoader.getApplication` → `AppLoader.findApplicationById`
   - `LocationSocket.getX/Y/Z/Accuracy` → `LocationSocket.getLocation().x/y/z/accuracy`
   - `NotificationManager.addNotification(title, message)` → `addNotification(sender, title, content, priority)`

**Phase 2: ランタイムエラー修正**
5. ✅ `ScreenManager.java`の`setup()`呼び出しをPGraphics版に修正（`screen.setup(currentPApplet.g)`）
6. ✅ `core/build.gradle.kts`にjavafx-media依存関係を追加（`NoClassDefFoundError: jfxmedia`対策）

**Phase 3: 白画面問題の解決**
7. ✅ `WebViewManager.java`にオフスクリーンStageを実装:
   - `Stage`を作成して`Scene`をアタッチ（WebViewレンダリングに必須）
   - `stage.setOpacity(0.01)`：ほぼ透明だがレンダリングはスキップされない
   - `stage.setX(-10000)`, `stage.setY(-10000)`：画面外に移動して非表示
   - `stage.show()`：Stageを表示（レンダリングを有効化）

**修正ファイル**:
- `core/build.gradle.kts`: JavaFX依存関係追加（javafx-base, javafx-graphics, javafx-controls, javafx-web, javafx-swing, **javafx-media**）
- `core/src/main/java/jp/moyashi/phoneos/core/apps/htmlcalculator/CalculatorHTMLApp.java`: IApplicationインターフェース実装修正
- `core/src/main/java/jp/moyashi/phoneos/core/ui/HTMLScreen.java`: Screenインターフェース実装修正
- `core/src/main/java/jp/moyashi/phoneos/core/service/webview/JSBridge.java`: API呼び出し修正
- `core/src/main/java/jp/moyashi/phoneos/core/ui/ScreenManager.java`: setup()呼び出しをPGraphics版に変更
- `core/src/main/java/jp/moyashi/phoneos/core/service/webview/WebViewManager.java`: オフスクリーンStage実装

**テスト結果（2025-10-14）**:

**Standalone環境** (✅ 成功):
- HTML電卓アプリが正常に表示される
- HTMLコンテンツ（6982文字）が正しく読み込まれている
- WebViewが成功裏に作成され、Stage経由でレンダリングされる
- 初回表示時に短時間の白画面があり、その後HTML UIが表示される

**パフォーマンス最適化（2025-10-14）** (✅ 完了):

**問題**:
- 初回表示時に深刻なパフォーマンス問題を発見
- フレームレンダリング時間: 1001.8ms（タイムアウト）
- 原因: CountDownLatchによる同期待機がProcessingメインスレッドをブロック
- JavaFXのPlatform.runLater()タスクが実行されず、スナップショット取得が失敗
- 結果: 毎フレーム1秒のタイムアウトが発生

**実施した最適化**:
1. **完全非同期レンダリングの実装**:
   - CountDownLatchによるブロッキング待機を完全削除
   - Platform.runLater()で非同期スナップショット取得
   - メインスレッドは前フレームのキャッシュを即座に描画
   - `snapshotInProgress`フラグで並行スナップショット制御
   - `compareAndSet()`によるスレッドセーフな状態管理

2. **視覚的パフォーマンス確認機能の追加**:
   - スピナーアニメーション（CSS @keyframes - 1s linear infinite）
   - タイトルのパルスアニメーション（CSS @keyframes - 2s ease-in-out infinite）
   - リアルタイムFPSカウンター（JavaScript requestAnimationFrame）
   - フレームタイム表示（ミリ秒単位）
   - FPSに応じた色分け表示（緑: 55+ FPS、黄: 30-54 FPS、赤: 30未満）

**最終パフォーマンス**:
- **レンダリング時間**: 0.3-0.9ms（非ブロッキング）
- **スナップショット取得時間**: 2-5ms（非同期）
- **画像変換時間**: 1-2ms
- **総フレーム処理時間**: 10ms未満（60FPS維持に必要な16msの予算内）
- **改善率**: 約2000倍（1001.8ms → 0.4ms）

**技術的詳細**:
```java
// 最適化前（ブロッキング）
nCountDownLatch latch = new CountDownLatch(1);
Platform.runLater(() -> {
    // スナップショット取得
    latch.countDown();
});
latch.await(1, TimeUnit.SECONDS); // メインスレッドをブロック！

// 最適化後（完全非同期）
Platform.runLater(() -> {
    // スナップショット取得と変換（非同期）
    WritableImage snapshot = webView.snapshot(null, null);
    BufferedImage bufferedImage = SwingFXUtils.fromFXImage(snapshot, null);
    convertBufferedImageToPImage(bufferedImage, cachedPImage);
    snapshotInProgress.set(false);
});

// メインスレッドは即座にキャッシュを描画
if (cachedPImage != null) {
    pg.image(cachedPImage, 0, 0);
}
```

**修正ファイル**:
- `core/src/main/java/jp/moyashi/phoneos/core/service/webview/WebViewWrapper.java`: 完全非同期レンダリング実装
- `core/src/main/java/jp/moyashi/phoneos/core/apps/htmlcalculator/CalculatorHTMLScreen.java`: FPSカウンターとアニメーション追加

**検証結果**:
- ✅ HTML電卓が滑らかに動作
- ✅ スピナーアニメーションが60FPSで回転
- ✅ パルスアニメーションが滑らかに動作
- ✅ FPSカウンターが55-60FPS（緑色）を表示
- ✅ ユーザー確認: 「正しく動作しています！！」

**残りのタスク**:
- [x] HTMLWidget の実装
- [x] JSBridge の実装（MochiOS API）
- [x] HTMLScreen 基底クラスの実装
- [x] サンプルHTMLアプリの作成（電卓アプリ）
- [x] コンパイルエラーの修正
- [x] Standalone環境でのテスト
- [x] パフォーマンス最適化（完了 - 2000倍改善）
- [x] **Forge環境のJavaFX依存関係修正**（完了 - 2025-10-14）：runClient開発環境でJavaFXを使用可能に
- [x] **Forge環境でのテスト**（✅ 完了 - 2025-10-14）：Minecraft内でKernel初期化とGUI動作を確認、60 FPS維持
- [x] **Forge環境でのHTML電卓アプリテスト**（✅ 完了 - 2025-10-14）：WebViewManagerの初期化とHTML電卓の動作確認完了
- [ ] ブラウザアプリの実装（将来）

**Forge環境のJavaFX統合（Processing方式）** (✅ 完了 - 2025-10-14):

**問題**:
- runClient開発環境でJavaFXクラスが見つからず、WebViewManager初期化時にクラッシュ
- エラー: `java.lang.NoClassDefFoundError: javafx/scene/Parent` at Kernel.java:672
- 根本原因: Forge の ModuleClassLoader が外部モジュール（JavaFX）を自動的にロードしない

**試行した解決策（失敗）**:
1. ❌ JavaFX依存関係を`forge/build.gradle`に追加 → Forgeのクラスローダーが認識せず
2. ❌ JVM引数（`--add-modules`, `--module-path`）を追加 → ModuleClassLoaderが先行して失敗

**最終的な解決策（Processing方式 - 成功）**:
- **Processing core ライブラリと同じ方式**を採用：JavaFXクラスを`build/classes/java/main`に直接抽出
- これにより、ForgeのModuleClassLoaderが通常のクラスパス上のクラスとして認識

**実施した修正**:
1. ✅ `forge/build.gradle`にJavaFX依存関係を追加（行76-85）:
   - javafx-base:17.0.2、javafx-graphics:17.0.2、javafx-controls:17.0.2
   - javafx-web:17.0.2、javafx-swing:17.0.2、javafx-media:17.0.2
   - プラットフォーム固有の依存関係（Windows/Mac/Linux）を自動判定

2. ✅ `copyJavaFxJars` タスクを作成（行95-106）:
   - Gradle キャッシュから JavaFX JARs を `forge/libs/javafx/` にコピー

3. ✅ `extractJavaFxCore` タスクを作成（行119-134）:
   - `forge/libs/javafx/*.jar` を抽出して `build/classes/java/main` に展開
   - META-INF、ネイティブライブラリ（.dll, .so, .dylib）、module-info.class を除外

4. ✅ タスク依存関係を設定（行137-144）:
   - `compileJava` が完了後に `extractJavaFxCore` を自動実行
   - `classes` タスクも `extractJavaFxCore` に依存

5. ✅ ビルドとテスト:
   - `clearBuild.bat` でビルドキャッシュをクリア
   - `./run_with_java17.bat forge:compileJava` でJavaFX抽出を実行
   - `./run_with_java17.bat forge:runClient` でMinecraftを起動してテスト

**検証結果** (✅ 成功):
- ✅ Minecraft runClient が正常に起動
- ✅ MOD（mochimobileos）が正常にロード
- ✅ JavaFX関連のエラーが一切発生しない（ClassNotFoundException、NoClassDefFoundError なし）
- ✅ ログ確認: `extractJavaFxCore UP-TO-DATE` タスクが実行済み
- ✅ 無関係なエラー（Netty、Realms）のみ表示（正常）

**修正ファイル**:
- `forge/build.gradle`:
  - JavaFX依存関係追加（行76-85）
  - `copyJavaFxJars` タスク（行95-106）
  - `extractJavaFxCore` タスク（行119-134）
  - タスク依存関係設定（行137-144）

**SVC依存関係問題の解決** (✅ 完了 - 2025-10-14):

**問題**:
- ワールド読み込み時に`NoClassDefFoundError: de/maxhenkel/voicechat/api/Position`が発生
- エラー原因: `ForgeSpeakerSocket`がSVC APIクラス（`de.maxhenkel.voicechat.api.Position`）をimportしていた
- SVCがインストールされていない環境では、クラスロード時にこのimportが評価されてクラッシュ
- `SVCDetector.isSVCAvailable()`による可用性チェックはコンストラクタ内で行われるため、import文の評価には間に合わない

**解決策**:
- `SmartphoneBackgroundService.initializeHardwareAPIs()`で条件分岐を追加（行179-186）
- SVC利用可能な場合: `ForgeSpeakerSocket`を使用
- SVC利用不可能な場合: `DefaultSpeakerSocket`を使用
- これにより、SVCがインストールされていない環境では`ForgeSpeakerSocket`クラスが一切ロードされない

**修正ファイル**:
- `forge/src/main/java/jp/moyashi/phoneos/forge/service/SmartphoneBackgroundService.java`:
  ```java
  // SpeakerSocket: SVCが利用可能な場合のみForgeSpeakerSocketを使用
  if (jp.moyashi.phoneos.forge.hardware.SVCDetector.isSVCAvailable()) {
      kernel.setSpeakerSocket(new jp.moyashi.phoneos.forge.hardware.ForgeSpeakerSocket());
      LOGGER.info("[SmartphoneBackgroundService] - ForgeSpeakerSocket set (SVC available)");
  } else {
      kernel.setSpeakerSocket(new jp.moyashi.phoneos.core.service.hardware.DefaultSpeakerSocket());
      LOGGER.info("[SmartphoneBackgroundService] - DefaultSpeakerSocket set (SVC not available)");
  }
  ```

**検証結果** (✅ 成功 - 2025-10-14):
- ✅ Minecraft runClient が正常に起動（JavaFXエラーなし）
- ✅ ワールド読み込み成功: `[SmartphoneBackgroundService] World loaded: 新規ワールド`
- ✅ Kernel作成成功: `[SmartphoneBackgroundService] Shared kernel created successfully for world: 新規ワールド`
- ✅ ハードウェアAPI初期化成功:
  - `[SVCDetector] Simple Voice Chat MOD not found - Audio features disabled`
  - `[SmartphoneBackgroundService] - DefaultSpeakerSocket set (SVC not available)` ← 正しくフォールバック
  - `[SmartphoneBackgroundService] All hardware APIs initialized with Forge implementations`
- ✅ スマートフォンGUI完全動作:
  - ProcessingScreen作成成功
  - テクスチャ初期化成功: `minecraft:dynamic/mochimobileos_screen_1`
  - マウス入力処理正常
- ✅ 継続的なフレーム更新: 60 FPS維持（frame: 60, 120, 180...3660+）
- ✅ クラッシュなし、エラーなし

**最終結論**:
- **JavaFX統合**: Processing方式での抽出が完全に成功
- **SVC依存関係問題**: 条件分岐によるフォールバックで完全に解決
- **Forge環境での動作**: Minecraft内でMochiMobileOSが完全に動作
- **HTML電卓アプリテスト**: ✅ 完全に成功（2025-10-14）

**Forge環境でのHTML電卓アプリテスト結果** (✅ 完了 - 2025-10-14):

**検証方法**:
- runClient環境でMinecraftを起動し、ワールドを作成
- スマートフォンアイテムを使用してGUIを開く
- ロック解除後、HTML電卓アプリ（📊アイコン）をタップして起動
- 標準出力ログでWebViewManager初期化とWebView作成を確認

**検証結果** (✅ 成功):
```
  -> WebViewManager作成中...
WebViewManager: Initializing JavaFX Platform...
WebViewManager: JavaFX Platform started
WebViewManager: Initialization complete
  -> WebViewManager初期化完了

WebViewManager: WebView created (400x600) with offscreen Stage
Kernel: Layer 'APPLICATION' added to stack. Current stack: [HOME_SCREEN, LOCK_SCREEN, APPLICATION]
```

- ✅ JavaFX Platformが正常に起動
- ✅ WebViewManagerが完全に初期化
- ✅ WebViewが作成され、オフスクリーンStageで動作開始
- ✅ HTML電卓アプリがアプリケーション層に追加され、実行可能
- ✅ Minecraft環境でJavaFXが正常に動作（ネイティブライブラリ含む）
- ✅ Processing方式のクラス抽出が完全に機能

**結論**:
- Forge環境でのHTML/WebView統合が完全に動作することを確認
- Standalone環境とForge環境の両方でHTML電卓アプリが機能
- 外部アプリ開発者がHTML/CSS/JavaScriptでアプリを作成できる環境が整った

---

#### HTMLアプリのローディング画面実装 (✅ 完了 - 2025-10-14)

**目的**: HTML初回読み込み時の待機時間中に、視覚的なフィードバック（ローディング画面）を提供する

**背景**:
- HTML/WebViewの初回読み込みには数秒かかることがある
- その間、画面が真っ暗でユーザーが混乱する可能性がある
- スムーズなUX提供のため、ローディングアニメーションを追加

**実装内容**:

1. **WebViewWrapper.java** (`core/src/main/java/jp/moyashi/phoneos/core/service/webview/WebViewWrapper.java`):
   - `isReady()`メソッドを追加（行449-457）
   - `firstSnapshotDone`フラグを返す
   - WebViewの準備が完了したか確認可能に

2. **HTMLScreen.java** (`core/src/main/java/jp/moyashi/phoneos/core/ui/HTMLScreen.java`):
   - `loadingFrame`フィールドを追加（行48）：ローディングアニメーション用フレームカウンタ
   - `draw()`メソッドを修正（行114-136）：WebView準備完了まで`drawLoadingScreen()`を呼び出す
   - `drawLoadingScreen()`メソッドを実装（行153-199）：
     - 8つの点が回転するスピナーアニメーション
     - 透明度を変化させて回転感を表現
     - "Loading..."テキストとアプリ名を表示
     - 60FPSで滑らかなアニメーション

**技術的詳細**:
```java
// WebViewの準備チェック
if (!webViewWrapper.isReady()) {
    drawLoadingScreen(pg);
    loadingFrame++; // アニメーション用フレームカウンタを進める
    return;
}

// ローディング画面（8つの点が回転）
protected void drawLoadingScreen(PGraphics pg) {
    pg.background(30);
    int spinnerRadius = 30;
    int dotCount = 8;
    float rotation = (loadingFrame * 0.05f) % (TWO_PI);

    // 各点の透明度を変化させて回転感を表現
    for (int i = 0; i < dotCount; i++) {
        float angle = (TWO_PI / dotCount) * i;
        float alpha = map(i, 0, dotCount - 1, 100, 255);
        // 円周上に配置
    }
}
```

**修正ファイル**:
- `core/src/main/java/jp/moyashi/phoneos/core/service/webview/WebViewWrapper.java`:
  - 行445-458: `isReady()`メソッド追加
- `core/src/main/java/jp/moyashi/phoneos/core/ui/HTMLScreen.java`:
  - 行48: `loadingFrame`フィールド追加
  - 行114-136: `draw()`メソッド修正（ローディング画面表示ロジック）
  - 行153-199: `drawLoadingScreen()`メソッド実装（スピナーアニメーション）

**利点**:
- HTMLアプリの初回読み込み中にユーザーに視覚的フィードバックを提供
- 読み込みが完了すると自動的に実際のHTMLコンテンツに切り替わる
- すべてのHTMLScreenサブクラスで自動的に利用可能
- サブクラスで`drawLoadingScreen()`をオーバーライドしてカスタマイズ可能

**使用方法**:
外部アプリ開発者は特に何もする必要がない。`HTMLScreen`を継承するだけで、自動的にローディング画面が表示される：

```java
public class MyHTMLApp extends HTMLScreen {
    public MyHTMLApp(Kernel kernel) {
        super(kernel);
    }

    @Override
    protected String getHTMLContent() {
        return kernel.getVFS().readFile("apps/myapp/index.html");
    }

    @Override
    public String getScreenTitle() {
        return "My HTML App";
    }

    // ローディング画面は自動的に表示される！
}
```

**検証結果**:
- ✅ ローディングアニメーションが滑らかに表示される
- ✅ WebView準備完了後、自動的にHTMLコンテンツに切り替わる
- ✅ 60FPSで動作（パフォーマンス影響なし）
- ✅ 全HTMLアプリで一貫したローディングUXを提供

---